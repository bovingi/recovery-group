legend("topright", material, bty = "n", fill = colors, inset = c(0.5, 0))
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("slateblue4", "red", "purple", "cyan")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(0.5, 0))
source('~/.active-rstudio-document', echo=TRUE)
# We are going to draw the first scatter plot of absorbance versus thickness.  The abline function, adds the best fit line to the data.  We are best fitting to the model of Y=MX+0.
par(mar = c(4, 4, 2, 5))
plot(abs ~ thickness, data = d,
xlab = "Thickness",
ylab = "Absorbance (AU)",
col = "red",
# Filled in diamonds
pch = 18,
# Make points a little bigger (cex = 1 is default)
cex = 1.3)
abline(lm(abs ~ thickness + 0))
fit1 <- lm(abs ~ thickness + 0, data =d)
# Now we will draw the second plot on top of the first.  Thr par(new=true) plots it on top of the previous graph.  This is a plot of transmittance versus thickness and is also fit to a straight line using the abline function below. Make sure that after you look at the fits of both transmittance and absorbance, you remove the abline command of the one that does not look linear (if there is one).
par(new = TRUE)
plot(trans ~ thickness, data = d,
axes = FALSE, xlab = NA, ylab = NA,
col = "blue", pch = 18, cex = 1.3)
fit2 <- lm(trans ~ thickness, data =d)
# Now we add the second axis to the plot and place it on the right side, 1 = below, 2 = left, 3 = above, 4 = right
axis(side = 4)
# mtext function writes a margin into a plot, this will add a second vertical axis label
# line = 3 scoots the title out a ways
mtext(side = 4, line = 3, "Transmittance %")
#You will also want to include the best fit line parameters in the caption.  In order to get the slope of your fit line, run this chunk and then type > fit1$coefficients or fit2$coefficients into your console.  This will give you the slope of the best fit line and if this is a good model, include this slope and its meaning in the graph caption.
fit2$coefficients
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(-0.5, 0))
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(-0.5, -.25))
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(-0.5, 0))
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(-0.5, 0.25))
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(-0.5, 0.2))
# Here is where you create your clustered bar graph.  Notice that we are clustering by element, so we can better see which shields work best for each element. This will allow you to determine the type of radioactivity each element is emitting.
# The line below allows us to choose the colors we want for our bar graph. If you want to change the colors, R colors can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
colors <- c("royalblue4", "orange1", "darkmagenta", "cyan3")
# the mar = c( ) allows use to change the placement of the plot.  The default is c(5, 4, 4, 2), where the numbers correspond to bottom, left, top, and right margins.  We need more room on the right to add the legond, therefore we have increased the 2 to a 9 below.
par(mar=c(5, 4, 4, 9), xpd = TRUE)
barplot(data,
beside=TRUE,
xlab="Shielding Element",
ylab="Tranmittance %",
axis.lty = 1,
col = colors)
# Below is where we add our legend.  Offset the legend so that it fits into the plotting region
legend("topright", material, bty = "n", fill = colors, inset = c(-0.5, 0.175))
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
Acer circinatum
library(oilabs)
library(ggplot2)
data(evals)
install.packages("devtools")
library(devtools)
install_github("andrewpbray")
library(oilabs)
data(evals)
```
install.packages("devtools")
library(devtools)
install_github("andrewpbray")
library(oilabs)
data(evals)
install.packages("devtools")
library(devtools)
install_github("andrewpbray")
library(oilabs)
data(evals)
install_github("andrewpbray/oilabs")
?evals
?eval
data(evals)
```
data(evals)
library(oilabs)
data(evals)
install_github("andrewpbray/oilabs")
library(oilabs)
data(evals)
install.package("scales")
?library
?install.packages
install.package("devtools")
install.packages("devtools")
library(oilabs)
install_github("andrewpbray/oilabs")
install_github("andrewpbray/oilabs", force = T)
library(oilabs)
install.packages("scales")
install.packages("scales")
library(oilabs)
data(evals)
View(evals)
visualize(score)
library(fitplc)
install.packages("fitplc")
library("dplyr", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("reshape2", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("tidyverse", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
summaryPico <- read.csv("/Users/user/Desktop/Thesis/2019.02.05_vcurve_summary_PICO.csv")
summaryPico
burnedPico <- summaryPico %>%
filter(summaryPico,Treatment=="burned")
controlPico <- summaryPico %>%
filter(Treatment == "control")
burnedPico <- summaryPico %>%
filter(summaryPico,Treatment=="burned")
View(controlPico)
burnedPico <- summaryPico %>%
filter(summaryPico,Treatment=="burned")
controlPico <- summaryPico %>%
filter(Treatment == "control")
burnedPico <- summaryPico %>%
filter(summaryPico,Treatment=="burned")
burnedPico <- summaryPico %>%
filter(summaryPico,Treatment=="burned")
burnedPico <- summaryPico %>%
filter(summaryPico,Treatment=="burned")
#subsetting the datasets to run curves according to treatments
#df1b <- subset(df1, Treatment =="burned")
#df1c <- subset(df1, Treatment =="control")
## not sure why we do this, ergo -- not doing.
# df2 <- read.csv("~/Bio/Thesis/2019.02.05_vcurve_summary_PICO.csv")
###analysis + plots
#individual fits
#control, according to PLC
pfit <- fitplc(controlPico, varnames=c(PLC="Fat.Cor.PLC", WP= "MPa"), nboot=1000)
plot(pfit)
### cool. can also figure out how to do this in ggplot() if you want.
### but ... ... for now, maybe that's good enough for folk music?
# Or plot the percent embolism using the what="embol" argument below
plot(pfit, what="embol", xlim=c(8,0))
coef(pfit)
pfit2c <-  fitplc(controlPico, varnames=c(PLC="Fat.Cor.PLC", WP="MPa"), nboot=1000, legend = ("Red is Burned, Black is Control"))
#to change the figure settings such as colors, see plot.plcfit {fitplc} in the help menu
plot(pfit, onepanel=TRUE, plotci=FALSE, px_ci="none", pxlinecol="navy", xlim=c(8,0), ylim=c(1,0), pointcol = "olivedrab", linecol = "maroon4")
#c <- coef(allfitc)
##write.csv(c, "control curve parameter.csv")
#burned
pfit2 <- fitplc(burnedPico, varnames=c(PLC ="Fat.Cor.PLC", WP="MPa"), nboot=1000)
#combine all plots into one image
## interesting plan, but perhaps not what the code is doing here ...
plot(pfit, what="embol", xlim=c(8,0), plotdata=F, px_ci_label=F, pxlinecol="black")
version
version
##reading in data and transforming columns into the proper format:
data1 = read.csv("03.09.2020.csv") %>%
mutate_at(vars(ID, spp, Flam.y.n, date), funs(as.character)) %>%
mutate_at(vars(LFMavg,LFMbottle, Flam.weight, start.temp.lower, start.temp.taller,
TTI, GPD, FH, FD, TTFG, GTI, PFG, mpa, bars,max.temp.taller,
FW, Dwdry, BWavg, BW1dry, BW2dry), funs(as.numeric)) %>%
#mutate_at(vars(date), funs(as.factor)) %>%
##creating avg. bottle column
mutate(BWavg1 = ((BW1dry + BW2dry)/2)) %>%
##calculating LFM using specific bottle weights, and then using avg. bottle weight
mutate(LFMbot1 = (((FW - BW1dry)-(Dwdry - BW2dry))/(Dwdry - BW2dry))*100) %>%
mutate(LFMavg1 = (((FW -Dwdry)/(Dwdry - BWavg1))*100)) %>%
#filter out really high and negative LFMs and changing neg flam metrics to 0
filter(LFMbot1 < 300) %>%
filter(LFMbot1 >0) %>%
mutate(TTI = replace(TTI, which(TTI<0), 0)) %>%
mutate(GPD = replace(GPD, which(GPD<0), 0)) %>%
mutate(TTFG = replace(TTFG, which(TTFG<0), 0)) %>%
mutate(GTI = replace(GTI, which(GTI<0), 0)) %>%
mutate(PFG = replace(PFG, which(PFG<0), 0)) %>%
#calculating RWC, as the water content relative to max LFM
mutate(ind = date.individual) %>%
group_by(ind) %>%
mutate(maxLFM = max(LFMbot1)) %>%
mutate(RWC = (LFMbot1/maxLFM)*100) %>% ##take out Rmax data for 2016, #
#do RWCmaxs get higher as they go? How to accomodate increasing hydration as we are measuring?
#%DW column ## take into account %DW,
mutate(Dwpercent = ((Dwdry/FW)*100))
knitr::opts_chunk$set(echo = TRUE)
### Install necessary packages ###
# install.packages("ggcust2")
# library(ggcust2)
#install.packages("viridis")
library(viridis)
#install.packages("RColorBrewer")
library(RColorBrewer)
#install.packages("tidyr")
library(tidyr)
#install.packages("here")
library(here)
library(gridExtra)
install.packages("agricolae")
library(agricolae)
library(ggpubr)
filter = dplyr::filter
select = dplyr::select
ggcust <- function(...){
ggplot(...) +
theme_bw()+
#scale_fill_brewer(palette="BrBG") +
scale_fill_manual(values = c("Unburned" = "#01665e",
"Pre Burn"="#5ab4ac",
"Burned"="#8c510a",
"One Year Post" = "#d8b365"))
}
ggplot2::theme_set(theme_bw())
treeKsData <- read.csv(here("raw-data", "KsData_combined.csv"), blank.lines.skip=T) %>%
unite(ID, c("Name", "Location", "Treatment"), remove = F, sep = ".") %>%
mutate(PLCnat = ((KsMax - KsNat)/KsMax)*100) %>%
mutate(Type = Species)
str(treeKsData)
treeKsData$Species <- factor(treeKsData$Species, levels = c("PIPO", "PICO", "PILA", "PSME", "CADE", "QUKE", "POTR"))
treeKsData$Type <- dplyr::recode(treeKsData$Type, PIPO = "Gymnosperm", PICO = "Gymnosperm", PSME = "Gymnosperm", CADE = "Gymnosperm", PILA = "Gymnosperm", QUKE = "Angiosperm", POTR = "Angiosperm")
treeKsData$Treatment <- factor(treeKsData$Treatment , levels=c("Unburned", "Pre Burn", "Burned", "One Year Post"))
str(treeKsData)
PIPO <- treeKsData %>% filter(Species  =="PICO")
PICO <- filter(treeKsData, Species=="PICO")
POTR <- filter(treeKsData, Species=="POTR")
Field <- filter(treeKsData, Location=="Field")
Lab <- filter(treeKsData, Location=="Lab") %>% filter(PLCnat > 0) ##This filters out
Indra <- filter(treeKsData, Name=="Boving")
Ariel <- filter(treeKsData, Name=="Patterson")
Price <- filter(treeKsData, Name=="Price")
Javin <- filter(treeKsData, Name == "DeMello")
Ksmax_all<- treeKsData %>%
filter(Name != "DeMello") %>%
filter(Treatment != "Unburned") %>%
ggcust(aes(x=Species, y=KsMax, fill=Treatment)) +
geom_boxplot()+
theme(legend.position = "right")
Ksmax_all
Ksmax_noPIPO<- treeKsData %>%
filter(Name != "DeMello") %>%
filter(Location == "Field") %>%
filter(Species != "PIPO") %>%
ggcust(aes(x=Species, y=KsMax, fill=ID)) +
geom_boxplot()+
theme(legend.position = "right")
Ksmax_noPIPO
Ksmax_PIPO <- treeKsData %>%
filter(Name != "DeMello") %>%
filter(Location == "Field") %>%
filter(Species == "PIPO") %>%
ggcust(aes(x=Species, y=KsMax, fill=ID)) +
geom_boxplot() +
theme(legend.position = "right")
Ksmax_PIPO
Ksmax_field_PIPO <- Field %>%
filter(Treatment != "Unburned") %>%
filter(Species == "PIPO") %>%
ggcust(aes(x=Species, y=KsMax, fill=Treatment)) +
geom_boxplot()+
xlab("")+
ylab("")
Ksmax_field_PIPO
Ksmax_field_PICO <- Field %>%
filter(Treatment != "Unburned") %>%
filter(Species == "PICO") %>%
ggcust(aes(x=Species, y=KsMax, fill=Treatment)) +
geom_boxplot()+
xlab("")
Ksmax_field_PICO
Ksmax_field_POTR <- Field %>%
filter(Treatment != "Unburned") %>%
filter(Species == "POTR") %>%
ggcust(aes(x=Species, y=KsMax, fill=Treatment)) +
geom_boxplot()+
xlab("")+
ylab("")
Ksmax_field_POTR
ggarrange(Ksmax_field_PIPO, Ksmax_field_PICO, Ksmax_field_POTR, nrow = 3,common.legend = TRUE, legend="bottom")
time.PIPO <- Field %>%
filter(Species == "PIPO") %>%
filter(Treatment != "Unburned")
Ksmax_aov <- aov(KsMax ~ Treatment, data= time.PIPO)
summary(Ksmax_aov)
time.PICO <- Field %>%
filter(Species == "PICO") %>%
filter(Treatment != "Unburned")
Ksmax_aov <- aov(KsMax ~ Treatment, data= time.PICO)
summary(Ksmax_aov)
time.POTR <- Field %>%
filter(Species == "POTR") %>%
filter(Treatment != "Unburned")
Ksmax_aov <- aov(KsMax ~ Treatment, data= time.POTR)
summary(Ksmax_aov)
posthoc <- HSD.test(Ksmax_aov, "Treatment")
posthoc
#"SNK is derived from Tukey, but it is less conservative (finds more differences). Tukey controls the error for all comparisons, where SNK only controls for comparisons under consideration. The level by alpha default is 0.05."
SNK <- SNK.test(Ksmax_aov, "Treatment")
SNK
tukey.test <- TukeyHSD(Ksmax_aov)
tukey.test
Lab.wide <- Lab %>%
pivot_wider(names_from = Treatment, values_from = PLCnat) %>%
mutate(PLCdiff = Burned - Unburned) %>%
select(Species, Tree, Burned, Unburned, PLCdiff)
PLC_lab<-Lab %>%
ggcust(aes(x=Species, y=PLCnat, fill=Treatment)) +
geom_boxplot()+
ggtitle("Lab") +
theme(legend.position = "right") +
xlab("") +
ylab("PLC")
PLC_lab
Ksmax_lab<-Lab %>%
ggcust(aes(x=Species, y=KsMax, fill=Treatment)) +
geom_boxplot()+
#ggtitle("Lab") +
xlab("") +
theme(legend.position = "right")
Ksmax_lab
Ksnat_lab<-Lab %>%
ggcust(aes(x=Species, y=KsNat, fill=Treatment)) +
geom_boxplot()+
#ggtitle("Lab") +
theme(legend.position = "right") +
xlab("Species") +
ylab("Ksnat")
Ksnat_lab
ggarrange(PLC_lab, Ksmax_lab, Ksnat_lab, common.legend = T, nrow = 3)
#+++++++++++++++++++++++++
# Function to calculate the mean and the standard deviation
# for each group
#+++++++++++++++++++++++++
# data : a data frame
# varname : the name of a column containing the variable
#to be summariezed
# groupnames : vector of column names to be used as
# grouping variables
data_summary <- function(data, varname, groupnames){
require(dplyr)
summary_func <- function(x, col){
c(mean = mean(x[[col]], na.rm=TRUE),
sd = sd(x[[col]], na.rm=TRUE))
}
data_sum<-ddply(data, groupnames, .fun=summary_func,
varname)
data_sum <- rename(data_sum, c("mean" = varname))
return(data_sum)
}
# add in
df2 <- data_summary(Lab, varname="PLCnat",
groupnames=c("Species", "Treatment"))
git config --global user.name "Indra Boving"
git config --global user.name "bovingi"
install.packages("usethis")
usethis::create_github_token()
gitcreds::gitcreds_set()
gitcreds::gitcreds_set()
usethis::git_sitrep()
usethis::git_sitrep()
gh_token_help()
gitcreds::gitcreds_set()
gitcreds_get()
install.packages("gitcreds")
install.packages("gitcreds")
gitcreds_get()
library(gitcreds)
gitcreds_get()
gitcreds_set()
gitcreds_set()
gitcreds_delete()
gitcreds_set()
gitcreds_set()
gitcreds_get()
gitcreds_set()
gitcreds_get
gitcreds_get()
install.packages("usethis")
usethis::create_github_token()
gitcreds::gitcreds_set()
usethis::git_sitrep()
.Tcl('set port /dev/cu.usbserial-00001004') 	#port number #############
########################### conductR #####################################
##########################################################################
#### an R program to measure plant hydraulic conductance with an #########
#### electronic balance or  pipette. #####################################
##########################################################################
#### Written by Duncan D. Smith 2012-2018 ################################
#### free to use and alter for all non-commercial purposes  ##############
#### Conceptually based on John Sperry's conduct.ver1.xls ################
##########################################################################
require(tcltk)									#load tcltk ##############
########################### conductR #####################################
##########################################################################
#### an R program to measure plant hydraulic conductance with an #########
#### electronic balance or  pipette. #####################################
##########################################################################
#### Written by Duncan D. Smith 2012-2018 ################################
#### free to use and alter for all non-commercial purposes  ##############
#### Conceptually based on John Sperry's conduct.ver1.xls ################
##########################################################################
require(tcltk)									#load tcltk ##############
install.packages("tcltk")
install.packages("tcltk")
library(here)
